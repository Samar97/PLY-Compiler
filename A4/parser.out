Created by PLY version 3.7 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> declarations funcdefs
Rule 2     funcdefs -> function funcdefs
Rule 3     funcdefs -> function
Rule 4     declarations -> declarations declaration
Rule 5     declarations -> <empty>
Rule 6     function -> ftypename LPAREN args RPAREN LBRACE statements RBRACE
Rule 7     ftypename -> type fname
Rule 8     type -> INT
Rule 9     type -> VOID
Rule 10    type -> FLOAT
Rule 11    fname -> ID
Rule 12    fname -> MAIN
Rule 13    args -> arg argcomp
Rule 14    args -> <empty>
Rule 15    argcomp -> COMMA arg argcomp
Rule 16    argcomp -> <empty>
Rule 17    arg -> type param
Rule 18    param -> var
Rule 19    param -> pointer
Rule 20    param -> address
Rule 21    var -> ID
Rule 22    const -> NUMBER
Rule 23    const -> FLOAT
Rule 24    pointer -> TIMES pointer
Rule 25    pointer -> TIMES address
Rule 26    pointer -> TIMES var
Rule 27    address -> AMPERSAND pointer
Rule 28    address -> AMPERSAND address
Rule 29    address -> AMPERSAND var
Rule 30    voidfuncall -> funcall SEMICOLON
Rule 31    funcall -> var LPAREN params RPAREN
Rule 32    params -> callparam paramcomp
Rule 33    params -> <empty>
Rule 34    paramcomp -> COMMA callparam paramcomp
Rule 35    paramcomp -> <empty>
Rule 36    callparam -> param
Rule 37    callparam -> const
Rule 38    statements -> statement statements
Rule 39    statements -> COMMENT statements
Rule 40    statements -> declaration statements
Rule 41    statements -> voidfuncall statements
Rule 42    statements -> <empty>
Rule 43    statement -> assignment
Rule 44    statement -> ifstatement
Rule 45    statement -> whilestatement
Rule 46    declaration -> type idlist SEMICOLON
Rule 47    idlist -> decl_var COMMA idlist
Rule 48    idlist -> decl_var
Rule 49    decl_var -> var
Rule 50    decl_var -> pointer
Rule 51    assignment -> pointer EQUALS expression SEMICOLON
Rule 52    assignment -> var EQUALS expression SEMICOLON
Rule 53    condition -> expression LT expression
Rule 54    condition -> expression GT expression
Rule 55    condition -> expression LE expression
Rule 56    condition -> expression GE expression
Rule 57    condition -> expression EQ expression
Rule 58    condition -> expression NE expression
Rule 59    condition -> condition AND condition
Rule 60    condition -> condition OR condition
Rule 61    condition -> NOT condition
Rule 62    condition -> LPAREN condition RPAREN
Rule 63    controlbody -> LBRACE statements RBRACE
Rule 64    controlbody -> statement
Rule 65    controlbody -> SEMICOLON
Rule 66    ifstatement -> IF LPAREN condition RPAREN controlbody
Rule 67    ifstatement -> IF LPAREN condition RPAREN controlbody ELSE controlbody
Rule 68    whilestatement -> WHILE LPAREN condition RPAREN controlbody
Rule 69    expression -> expression PLUS expression
Rule 70    expression -> expression MINUS expression
Rule 71    expression -> expression TIMES expression
Rule 72    expression -> expression DIVIDE expression
Rule 73    expression -> pointer
Rule 74    expression -> address
Rule 75    expression -> const
Rule 76    expression -> var
Rule 77    expression -> funcall
Rule 78    expression -> LPAREN expression RPAREN
Rule 79    expression -> MINUS expression

Terminals, with rules where they appear

AMPERSAND            : 27 28 29
AND                  : 59
COMMA                : 15 34 47
COMMENT              : 39
DIVIDE               : 72
ELSE                 : 67
EQ                   : 57
EQUALS               : 51 52
FLOAT                : 10 23
GE                   : 56
GT                   : 54
ID                   : 11 21
IF                   : 66 67
INT                  : 8
LBRACE               : 6 63
LE                   : 55
LPAREN               : 6 31 62 66 67 68 78
LT                   : 53
MAIN                 : 12
MINUS                : 70 79
NE                   : 58
NOT                  : 61
NUMBER               : 22
OR                   : 60
PLUS                 : 69
RBRACE               : 6 63
RPAREN               : 6 31 62 66 67 68 78
SEMICOLON            : 30 46 51 52 65
TIMES                : 24 25 26 71
VOID                 : 9
WHILE                : 68
error                : 

Nonterminals, with rules where they appear

address              : 20 25 28 74
arg                  : 13 15
argcomp              : 13 15
args                 : 6
assignment           : 43
callparam            : 32 34
condition            : 59 59 60 60 61 62 66 67 68
const                : 37 75
controlbody          : 66 67 67 68
decl_var             : 47 48
declaration          : 4 40
declarations         : 1 4
expression           : 51 52 53 53 54 54 55 55 56 56 57 57 58 58 69 69 70 70 71 71 72 72 78 79
fname                : 7
ftypename            : 6
funcall              : 30 77
funcdefs             : 1 2
function             : 2 3
idlist               : 46 47
ifstatement          : 44
param                : 17 36
paramcomp            : 32 34
params               : 31
pointer              : 19 24 27 50 51 73
program              : 0
statement            : 38 64
statements           : 6 38 39 40 41 63
type                 : 7 17 46
var                  : 18 26 29 31 49 52 76
voidfuncall          : 41
whilestatement       : 45

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declarations funcdefs
    (4) declarations -> . declarations declaration
    (5) declarations -> .

    INT             reduce using rule 5 (declarations -> .)
    VOID            reduce using rule 5 (declarations -> .)
    FLOAT           reduce using rule 5 (declarations -> .)

    program                        shift and go to state 1
    declarations                   shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> declarations . funcdefs
    (4) declarations -> declarations . declaration
    (2) funcdefs -> . function funcdefs
    (3) funcdefs -> . function
    (46) declaration -> . type idlist SEMICOLON
    (6) function -> . ftypename LPAREN args RPAREN LBRACE statements RBRACE
    (8) type -> . INT
    (9) type -> . VOID
    (10) type -> . FLOAT
    (7) ftypename -> . type fname

    INT             shift and go to state 5
    VOID            shift and go to state 10
    FLOAT           shift and go to state 7

    function                       shift and go to state 3
    funcdefs                       shift and go to state 4
    ftypename                      shift and go to state 6
    declaration                    shift and go to state 8
    type                           shift and go to state 9

state 3

    (2) funcdefs -> function . funcdefs
    (3) funcdefs -> function .
    (2) funcdefs -> . function funcdefs
    (3) funcdefs -> . function
    (6) function -> . ftypename LPAREN args RPAREN LBRACE statements RBRACE
    (7) ftypename -> . type fname
    (8) type -> . INT
    (9) type -> . VOID
    (10) type -> . FLOAT

    $end            reduce using rule 3 (funcdefs -> function .)
    INT             shift and go to state 5
    VOID            shift and go to state 10
    FLOAT           shift and go to state 7

    function                       shift and go to state 3
    funcdefs                       shift and go to state 11
    ftypename                      shift and go to state 6
    type                           shift and go to state 12

state 4

    (1) program -> declarations funcdefs .

    $end            reduce using rule 1 (program -> declarations funcdefs .)


state 5

    (8) type -> INT .

    ID              reduce using rule 8 (type -> INT .)
    TIMES           reduce using rule 8 (type -> INT .)
    AMPERSAND       reduce using rule 8 (type -> INT .)
    MAIN            reduce using rule 8 (type -> INT .)


state 6

    (6) function -> ftypename . LPAREN args RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 13


state 7

    (10) type -> FLOAT .

    ID              reduce using rule 10 (type -> FLOAT .)
    TIMES           reduce using rule 10 (type -> FLOAT .)
    AMPERSAND       reduce using rule 10 (type -> FLOAT .)
    MAIN            reduce using rule 10 (type -> FLOAT .)


state 8

    (4) declarations -> declarations declaration .

    INT             reduce using rule 4 (declarations -> declarations declaration .)
    VOID            reduce using rule 4 (declarations -> declarations declaration .)
    FLOAT           reduce using rule 4 (declarations -> declarations declaration .)


state 9

    (46) declaration -> type . idlist SEMICOLON
    (7) ftypename -> type . fname
    (47) idlist -> . decl_var COMMA idlist
    (48) idlist -> . decl_var
    (11) fname -> . ID
    (12) fname -> . MAIN
    (49) decl_var -> . var
    (50) decl_var -> . pointer
    (21) var -> . ID
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var

    ID              shift and go to state 20
    MAIN            shift and go to state 19
    TIMES           shift and go to state 16

    idlist                         shift and go to state 14
    fname                          shift and go to state 17
    var                            shift and go to state 18
    pointer                        shift and go to state 15
    decl_var                       shift and go to state 21

state 10

    (9) type -> VOID .

    ID              reduce using rule 9 (type -> VOID .)
    TIMES           reduce using rule 9 (type -> VOID .)
    AMPERSAND       reduce using rule 9 (type -> VOID .)
    MAIN            reduce using rule 9 (type -> VOID .)


state 11

    (2) funcdefs -> function funcdefs .

    $end            reduce using rule 2 (funcdefs -> function funcdefs .)


state 12

    (7) ftypename -> type . fname
    (11) fname -> . ID
    (12) fname -> . MAIN

    ID              shift and go to state 22
    MAIN            shift and go to state 19

    fname                          shift and go to state 17

state 13

    (6) function -> ftypename LPAREN . args RPAREN LBRACE statements RBRACE
    (13) args -> . arg argcomp
    (14) args -> .
    (17) arg -> . type param
    (8) type -> . INT
    (9) type -> . VOID
    (10) type -> . FLOAT

    RPAREN          reduce using rule 14 (args -> .)
    INT             shift and go to state 5
    VOID            shift and go to state 10
    FLOAT           shift and go to state 7

    args                           shift and go to state 23
    arg                            shift and go to state 24
    type                           shift and go to state 25

state 14

    (46) declaration -> type idlist . SEMICOLON

    SEMICOLON       shift and go to state 26


state 15

    (50) decl_var -> pointer .

    COMMA           reduce using rule 50 (decl_var -> pointer .)
    SEMICOLON       reduce using rule 50 (decl_var -> pointer .)


state 16

    (24) pointer -> TIMES . pointer
    (25) pointer -> TIMES . address
    (26) pointer -> TIMES . var
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (21) var -> . ID

    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    ID              shift and go to state 31

    var                            shift and go to state 29
    pointer                        shift and go to state 30
    address                        shift and go to state 28

state 17

    (7) ftypename -> type fname .

    LPAREN          reduce using rule 7 (ftypename -> type fname .)


state 18

    (49) decl_var -> var .

    COMMA           reduce using rule 49 (decl_var -> var .)
    SEMICOLON       reduce using rule 49 (decl_var -> var .)


state 19

    (12) fname -> MAIN .

    LPAREN          reduce using rule 12 (fname -> MAIN .)


state 20

    (11) fname -> ID .
    (21) var -> ID .

    LPAREN          reduce using rule 11 (fname -> ID .)
    COMMA           reduce using rule 21 (var -> ID .)
    SEMICOLON       reduce using rule 21 (var -> ID .)


state 21

    (47) idlist -> decl_var . COMMA idlist
    (48) idlist -> decl_var .

    COMMA           shift and go to state 32
    SEMICOLON       reduce using rule 48 (idlist -> decl_var .)


state 22

    (11) fname -> ID .

    LPAREN          reduce using rule 11 (fname -> ID .)


state 23

    (6) function -> ftypename LPAREN args . RPAREN LBRACE statements RBRACE

    RPAREN          shift and go to state 33


state 24

    (13) args -> arg . argcomp
    (15) argcomp -> . COMMA arg argcomp
    (16) argcomp -> .

    COMMA           shift and go to state 34
    RPAREN          reduce using rule 16 (argcomp -> .)

    argcomp                        shift and go to state 35

state 25

    (17) arg -> type . param
    (18) param -> . var
    (19) param -> . pointer
    (20) param -> . address
    (21) var -> . ID
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var

    ID              shift and go to state 31
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27

    var                            shift and go to state 38
    pointer                        shift and go to state 39
    param                          shift and go to state 36
    address                        shift and go to state 37

state 26

    (46) declaration -> type idlist SEMICOLON .

    INT             reduce using rule 46 (declaration -> type idlist SEMICOLON .)
    VOID            reduce using rule 46 (declaration -> type idlist SEMICOLON .)
    FLOAT           reduce using rule 46 (declaration -> type idlist SEMICOLON .)
    COMMENT         reduce using rule 46 (declaration -> type idlist SEMICOLON .)
    IF              reduce using rule 46 (declaration -> type idlist SEMICOLON .)
    WHILE           reduce using rule 46 (declaration -> type idlist SEMICOLON .)
    TIMES           reduce using rule 46 (declaration -> type idlist SEMICOLON .)
    ID              reduce using rule 46 (declaration -> type idlist SEMICOLON .)
    RBRACE          reduce using rule 46 (declaration -> type idlist SEMICOLON .)


state 27

    (27) address -> AMPERSAND . pointer
    (28) address -> AMPERSAND . address
    (29) address -> AMPERSAND . var
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (21) var -> . ID

    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    ID              shift and go to state 31

    var                            shift and go to state 41
    pointer                        shift and go to state 42
    address                        shift and go to state 40

state 28

    (25) pointer -> TIMES address .

    COMMA           reduce using rule 25 (pointer -> TIMES address .)
    SEMICOLON       reduce using rule 25 (pointer -> TIMES address .)
    RPAREN          reduce using rule 25 (pointer -> TIMES address .)
    EQUALS          reduce using rule 25 (pointer -> TIMES address .)
    LT              reduce using rule 25 (pointer -> TIMES address .)
    GT              reduce using rule 25 (pointer -> TIMES address .)
    LE              reduce using rule 25 (pointer -> TIMES address .)
    GE              reduce using rule 25 (pointer -> TIMES address .)
    EQ              reduce using rule 25 (pointer -> TIMES address .)
    NE              reduce using rule 25 (pointer -> TIMES address .)
    PLUS            reduce using rule 25 (pointer -> TIMES address .)
    MINUS           reduce using rule 25 (pointer -> TIMES address .)
    TIMES           reduce using rule 25 (pointer -> TIMES address .)
    DIVIDE          reduce using rule 25 (pointer -> TIMES address .)
    AND             reduce using rule 25 (pointer -> TIMES address .)
    OR              reduce using rule 25 (pointer -> TIMES address .)


state 29

    (26) pointer -> TIMES var .

    COMMA           reduce using rule 26 (pointer -> TIMES var .)
    SEMICOLON       reduce using rule 26 (pointer -> TIMES var .)
    RPAREN          reduce using rule 26 (pointer -> TIMES var .)
    EQUALS          reduce using rule 26 (pointer -> TIMES var .)
    LT              reduce using rule 26 (pointer -> TIMES var .)
    GT              reduce using rule 26 (pointer -> TIMES var .)
    LE              reduce using rule 26 (pointer -> TIMES var .)
    GE              reduce using rule 26 (pointer -> TIMES var .)
    EQ              reduce using rule 26 (pointer -> TIMES var .)
    NE              reduce using rule 26 (pointer -> TIMES var .)
    PLUS            reduce using rule 26 (pointer -> TIMES var .)
    MINUS           reduce using rule 26 (pointer -> TIMES var .)
    TIMES           reduce using rule 26 (pointer -> TIMES var .)
    DIVIDE          reduce using rule 26 (pointer -> TIMES var .)
    AND             reduce using rule 26 (pointer -> TIMES var .)
    OR              reduce using rule 26 (pointer -> TIMES var .)


state 30

    (24) pointer -> TIMES pointer .

    COMMA           reduce using rule 24 (pointer -> TIMES pointer .)
    SEMICOLON       reduce using rule 24 (pointer -> TIMES pointer .)
    RPAREN          reduce using rule 24 (pointer -> TIMES pointer .)
    EQUALS          reduce using rule 24 (pointer -> TIMES pointer .)
    LT              reduce using rule 24 (pointer -> TIMES pointer .)
    GT              reduce using rule 24 (pointer -> TIMES pointer .)
    LE              reduce using rule 24 (pointer -> TIMES pointer .)
    GE              reduce using rule 24 (pointer -> TIMES pointer .)
    EQ              reduce using rule 24 (pointer -> TIMES pointer .)
    NE              reduce using rule 24 (pointer -> TIMES pointer .)
    PLUS            reduce using rule 24 (pointer -> TIMES pointer .)
    MINUS           reduce using rule 24 (pointer -> TIMES pointer .)
    TIMES           reduce using rule 24 (pointer -> TIMES pointer .)
    DIVIDE          reduce using rule 24 (pointer -> TIMES pointer .)
    AND             reduce using rule 24 (pointer -> TIMES pointer .)
    OR              reduce using rule 24 (pointer -> TIMES pointer .)


state 31

    (21) var -> ID .

    LPAREN          reduce using rule 21 (var -> ID .)
    PLUS            reduce using rule 21 (var -> ID .)
    MINUS           reduce using rule 21 (var -> ID .)
    TIMES           reduce using rule 21 (var -> ID .)
    DIVIDE          reduce using rule 21 (var -> ID .)
    RPAREN          reduce using rule 21 (var -> ID .)
    AND             reduce using rule 21 (var -> ID .)
    OR              reduce using rule 21 (var -> ID .)
    LT              reduce using rule 21 (var -> ID .)
    GT              reduce using rule 21 (var -> ID .)
    LE              reduce using rule 21 (var -> ID .)
    GE              reduce using rule 21 (var -> ID .)
    EQ              reduce using rule 21 (var -> ID .)
    NE              reduce using rule 21 (var -> ID .)
    COMMA           reduce using rule 21 (var -> ID .)
    SEMICOLON       reduce using rule 21 (var -> ID .)
    EQUALS          reduce using rule 21 (var -> ID .)


state 32

    (47) idlist -> decl_var COMMA . idlist
    (47) idlist -> . decl_var COMMA idlist
    (48) idlist -> . decl_var
    (49) decl_var -> . var
    (50) decl_var -> . pointer
    (21) var -> . ID
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var

    ID              shift and go to state 31
    TIMES           shift and go to state 16

    var                            shift and go to state 18
    pointer                        shift and go to state 15
    idlist                         shift and go to state 43
    decl_var                       shift and go to state 21

state 33

    (6) function -> ftypename LPAREN args RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 44


state 34

    (15) argcomp -> COMMA . arg argcomp
    (17) arg -> . type param
    (8) type -> . INT
    (9) type -> . VOID
    (10) type -> . FLOAT

    INT             shift and go to state 5
    VOID            shift and go to state 10
    FLOAT           shift and go to state 7

    type                           shift and go to state 25
    arg                            shift and go to state 45

state 35

    (13) args -> arg argcomp .

    RPAREN          reduce using rule 13 (args -> arg argcomp .)


state 36

    (17) arg -> type param .

    COMMA           reduce using rule 17 (arg -> type param .)
    RPAREN          reduce using rule 17 (arg -> type param .)


state 37

    (20) param -> address .

    COMMA           reduce using rule 20 (param -> address .)
    RPAREN          reduce using rule 20 (param -> address .)


state 38

    (18) param -> var .

    COMMA           reduce using rule 18 (param -> var .)
    RPAREN          reduce using rule 18 (param -> var .)


state 39

    (19) param -> pointer .

    COMMA           reduce using rule 19 (param -> pointer .)
    RPAREN          reduce using rule 19 (param -> pointer .)


state 40

    (28) address -> AMPERSAND address .

    COMMA           reduce using rule 28 (address -> AMPERSAND address .)
    SEMICOLON       reduce using rule 28 (address -> AMPERSAND address .)
    RPAREN          reduce using rule 28 (address -> AMPERSAND address .)
    EQUALS          reduce using rule 28 (address -> AMPERSAND address .)
    LT              reduce using rule 28 (address -> AMPERSAND address .)
    GT              reduce using rule 28 (address -> AMPERSAND address .)
    LE              reduce using rule 28 (address -> AMPERSAND address .)
    GE              reduce using rule 28 (address -> AMPERSAND address .)
    EQ              reduce using rule 28 (address -> AMPERSAND address .)
    NE              reduce using rule 28 (address -> AMPERSAND address .)
    PLUS            reduce using rule 28 (address -> AMPERSAND address .)
    MINUS           reduce using rule 28 (address -> AMPERSAND address .)
    TIMES           reduce using rule 28 (address -> AMPERSAND address .)
    DIVIDE          reduce using rule 28 (address -> AMPERSAND address .)
    AND             reduce using rule 28 (address -> AMPERSAND address .)
    OR              reduce using rule 28 (address -> AMPERSAND address .)


state 41

    (29) address -> AMPERSAND var .

    COMMA           reduce using rule 29 (address -> AMPERSAND var .)
    SEMICOLON       reduce using rule 29 (address -> AMPERSAND var .)
    RPAREN          reduce using rule 29 (address -> AMPERSAND var .)
    EQUALS          reduce using rule 29 (address -> AMPERSAND var .)
    LT              reduce using rule 29 (address -> AMPERSAND var .)
    GT              reduce using rule 29 (address -> AMPERSAND var .)
    LE              reduce using rule 29 (address -> AMPERSAND var .)
    GE              reduce using rule 29 (address -> AMPERSAND var .)
    EQ              reduce using rule 29 (address -> AMPERSAND var .)
    NE              reduce using rule 29 (address -> AMPERSAND var .)
    PLUS            reduce using rule 29 (address -> AMPERSAND var .)
    MINUS           reduce using rule 29 (address -> AMPERSAND var .)
    TIMES           reduce using rule 29 (address -> AMPERSAND var .)
    DIVIDE          reduce using rule 29 (address -> AMPERSAND var .)
    AND             reduce using rule 29 (address -> AMPERSAND var .)
    OR              reduce using rule 29 (address -> AMPERSAND var .)


state 42

    (27) address -> AMPERSAND pointer .

    COMMA           reduce using rule 27 (address -> AMPERSAND pointer .)
    SEMICOLON       reduce using rule 27 (address -> AMPERSAND pointer .)
    RPAREN          reduce using rule 27 (address -> AMPERSAND pointer .)
    EQUALS          reduce using rule 27 (address -> AMPERSAND pointer .)
    LT              reduce using rule 27 (address -> AMPERSAND pointer .)
    GT              reduce using rule 27 (address -> AMPERSAND pointer .)
    LE              reduce using rule 27 (address -> AMPERSAND pointer .)
    GE              reduce using rule 27 (address -> AMPERSAND pointer .)
    EQ              reduce using rule 27 (address -> AMPERSAND pointer .)
    NE              reduce using rule 27 (address -> AMPERSAND pointer .)
    PLUS            reduce using rule 27 (address -> AMPERSAND pointer .)
    MINUS           reduce using rule 27 (address -> AMPERSAND pointer .)
    TIMES           reduce using rule 27 (address -> AMPERSAND pointer .)
    DIVIDE          reduce using rule 27 (address -> AMPERSAND pointer .)
    AND             reduce using rule 27 (address -> AMPERSAND pointer .)
    OR              reduce using rule 27 (address -> AMPERSAND pointer .)


state 43

    (47) idlist -> decl_var COMMA idlist .

    SEMICOLON       reduce using rule 47 (idlist -> decl_var COMMA idlist .)


state 44

    (6) function -> ftypename LPAREN args RPAREN LBRACE . statements RBRACE
    (38) statements -> . statement statements
    (39) statements -> . COMMENT statements
    (40) statements -> . declaration statements
    (41) statements -> . voidfuncall statements
    (42) statements -> .
    (43) statement -> . assignment
    (44) statement -> . ifstatement
    (45) statement -> . whilestatement
    (46) declaration -> . type idlist SEMICOLON
    (30) voidfuncall -> . funcall SEMICOLON
    (51) assignment -> . pointer EQUALS expression SEMICOLON
    (52) assignment -> . var EQUALS expression SEMICOLON
    (66) ifstatement -> . IF LPAREN condition RPAREN controlbody
    (67) ifstatement -> . IF LPAREN condition RPAREN controlbody ELSE controlbody
    (68) whilestatement -> . WHILE LPAREN condition RPAREN controlbody
    (8) type -> . INT
    (9) type -> . VOID
    (10) type -> . FLOAT
    (31) funcall -> . var LPAREN params RPAREN
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (21) var -> . ID

    COMMENT         shift and go to state 50
    RBRACE          reduce using rule 42 (statements -> .)
    IF              shift and go to state 58
    WHILE           shift and go to state 48
    INT             shift and go to state 5
    VOID            shift and go to state 10
    FLOAT           shift and go to state 7
    TIMES           shift and go to state 16
    ID              shift and go to state 31

    statements                     shift and go to state 46
    statement                      shift and go to state 52
    assignment                     shift and go to state 56
    whilestatement                 shift and go to state 51
    funcall                        shift and go to state 47
    voidfuncall                    shift and go to state 55
    declaration                    shift and go to state 57
    var                            shift and go to state 53
    type                           shift and go to state 54
    pointer                        shift and go to state 49
    ifstatement                    shift and go to state 59

state 45

    (15) argcomp -> COMMA arg . argcomp
    (15) argcomp -> . COMMA arg argcomp
    (16) argcomp -> .

    COMMA           shift and go to state 34
    RPAREN          reduce using rule 16 (argcomp -> .)

    argcomp                        shift and go to state 60

state 46

    (6) function -> ftypename LPAREN args RPAREN LBRACE statements . RBRACE

    RBRACE          shift and go to state 61


state 47

    (30) voidfuncall -> funcall . SEMICOLON

    SEMICOLON       shift and go to state 62


state 48

    (68) whilestatement -> WHILE . LPAREN condition RPAREN controlbody

    LPAREN          shift and go to state 63


state 49

    (51) assignment -> pointer . EQUALS expression SEMICOLON

    EQUALS          shift and go to state 64


state 50

    (39) statements -> COMMENT . statements
    (38) statements -> . statement statements
    (39) statements -> . COMMENT statements
    (40) statements -> . declaration statements
    (41) statements -> . voidfuncall statements
    (42) statements -> .
    (43) statement -> . assignment
    (44) statement -> . ifstatement
    (45) statement -> . whilestatement
    (46) declaration -> . type idlist SEMICOLON
    (30) voidfuncall -> . funcall SEMICOLON
    (51) assignment -> . pointer EQUALS expression SEMICOLON
    (52) assignment -> . var EQUALS expression SEMICOLON
    (66) ifstatement -> . IF LPAREN condition RPAREN controlbody
    (67) ifstatement -> . IF LPAREN condition RPAREN controlbody ELSE controlbody
    (68) whilestatement -> . WHILE LPAREN condition RPAREN controlbody
    (8) type -> . INT
    (9) type -> . VOID
    (10) type -> . FLOAT
    (31) funcall -> . var LPAREN params RPAREN
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (21) var -> . ID

    COMMENT         shift and go to state 50
    RBRACE          reduce using rule 42 (statements -> .)
    IF              shift and go to state 58
    WHILE           shift and go to state 48
    INT             shift and go to state 5
    VOID            shift and go to state 10
    FLOAT           shift and go to state 7
    TIMES           shift and go to state 16
    ID              shift and go to state 31

    statements                     shift and go to state 65
    statement                      shift and go to state 52
    assignment                     shift and go to state 56
    whilestatement                 shift and go to state 51
    funcall                        shift and go to state 47
    voidfuncall                    shift and go to state 55
    declaration                    shift and go to state 57
    var                            shift and go to state 53
    type                           shift and go to state 54
    pointer                        shift and go to state 49
    ifstatement                    shift and go to state 59

state 51

    (45) statement -> whilestatement .

    COMMENT         reduce using rule 45 (statement -> whilestatement .)
    IF              reduce using rule 45 (statement -> whilestatement .)
    WHILE           reduce using rule 45 (statement -> whilestatement .)
    INT             reduce using rule 45 (statement -> whilestatement .)
    VOID            reduce using rule 45 (statement -> whilestatement .)
    FLOAT           reduce using rule 45 (statement -> whilestatement .)
    TIMES           reduce using rule 45 (statement -> whilestatement .)
    ID              reduce using rule 45 (statement -> whilestatement .)
    RBRACE          reduce using rule 45 (statement -> whilestatement .)
    ELSE            reduce using rule 45 (statement -> whilestatement .)


state 52

    (38) statements -> statement . statements
    (38) statements -> . statement statements
    (39) statements -> . COMMENT statements
    (40) statements -> . declaration statements
    (41) statements -> . voidfuncall statements
    (42) statements -> .
    (43) statement -> . assignment
    (44) statement -> . ifstatement
    (45) statement -> . whilestatement
    (46) declaration -> . type idlist SEMICOLON
    (30) voidfuncall -> . funcall SEMICOLON
    (51) assignment -> . pointer EQUALS expression SEMICOLON
    (52) assignment -> . var EQUALS expression SEMICOLON
    (66) ifstatement -> . IF LPAREN condition RPAREN controlbody
    (67) ifstatement -> . IF LPAREN condition RPAREN controlbody ELSE controlbody
    (68) whilestatement -> . WHILE LPAREN condition RPAREN controlbody
    (8) type -> . INT
    (9) type -> . VOID
    (10) type -> . FLOAT
    (31) funcall -> . var LPAREN params RPAREN
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (21) var -> . ID

    COMMENT         shift and go to state 50
    RBRACE          reduce using rule 42 (statements -> .)
    IF              shift and go to state 58
    WHILE           shift and go to state 48
    INT             shift and go to state 5
    VOID            shift and go to state 10
    FLOAT           shift and go to state 7
    TIMES           shift and go to state 16
    ID              shift and go to state 31

    statements                     shift and go to state 66
    statement                      shift and go to state 52
    assignment                     shift and go to state 56
    whilestatement                 shift and go to state 51
    funcall                        shift and go to state 47
    voidfuncall                    shift and go to state 55
    declaration                    shift and go to state 57
    var                            shift and go to state 53
    type                           shift and go to state 54
    pointer                        shift and go to state 49
    ifstatement                    shift and go to state 59

state 53

    (52) assignment -> var . EQUALS expression SEMICOLON
    (31) funcall -> var . LPAREN params RPAREN

    EQUALS          shift and go to state 67
    LPAREN          shift and go to state 68


state 54

    (46) declaration -> type . idlist SEMICOLON
    (47) idlist -> . decl_var COMMA idlist
    (48) idlist -> . decl_var
    (49) decl_var -> . var
    (50) decl_var -> . pointer
    (21) var -> . ID
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var

    ID              shift and go to state 31
    TIMES           shift and go to state 16

    idlist                         shift and go to state 14
    var                            shift and go to state 18
    pointer                        shift and go to state 15
    decl_var                       shift and go to state 21

state 55

    (41) statements -> voidfuncall . statements
    (38) statements -> . statement statements
    (39) statements -> . COMMENT statements
    (40) statements -> . declaration statements
    (41) statements -> . voidfuncall statements
    (42) statements -> .
    (43) statement -> . assignment
    (44) statement -> . ifstatement
    (45) statement -> . whilestatement
    (46) declaration -> . type idlist SEMICOLON
    (30) voidfuncall -> . funcall SEMICOLON
    (51) assignment -> . pointer EQUALS expression SEMICOLON
    (52) assignment -> . var EQUALS expression SEMICOLON
    (66) ifstatement -> . IF LPAREN condition RPAREN controlbody
    (67) ifstatement -> . IF LPAREN condition RPAREN controlbody ELSE controlbody
    (68) whilestatement -> . WHILE LPAREN condition RPAREN controlbody
    (8) type -> . INT
    (9) type -> . VOID
    (10) type -> . FLOAT
    (31) funcall -> . var LPAREN params RPAREN
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (21) var -> . ID

    COMMENT         shift and go to state 50
    RBRACE          reduce using rule 42 (statements -> .)
    IF              shift and go to state 58
    WHILE           shift and go to state 48
    INT             shift and go to state 5
    VOID            shift and go to state 10
    FLOAT           shift and go to state 7
    TIMES           shift and go to state 16
    ID              shift and go to state 31

    statements                     shift and go to state 69
    voidfuncall                    shift and go to state 55
    assignment                     shift and go to state 56
    whilestatement                 shift and go to state 51
    funcall                        shift and go to state 47
    statement                      shift and go to state 52
    declaration                    shift and go to state 57
    var                            shift and go to state 53
    type                           shift and go to state 54
    pointer                        shift and go to state 49
    ifstatement                    shift and go to state 59

state 56

    (43) statement -> assignment .

    COMMENT         reduce using rule 43 (statement -> assignment .)
    IF              reduce using rule 43 (statement -> assignment .)
    WHILE           reduce using rule 43 (statement -> assignment .)
    INT             reduce using rule 43 (statement -> assignment .)
    VOID            reduce using rule 43 (statement -> assignment .)
    FLOAT           reduce using rule 43 (statement -> assignment .)
    TIMES           reduce using rule 43 (statement -> assignment .)
    ID              reduce using rule 43 (statement -> assignment .)
    RBRACE          reduce using rule 43 (statement -> assignment .)
    ELSE            reduce using rule 43 (statement -> assignment .)


state 57

    (40) statements -> declaration . statements
    (38) statements -> . statement statements
    (39) statements -> . COMMENT statements
    (40) statements -> . declaration statements
    (41) statements -> . voidfuncall statements
    (42) statements -> .
    (43) statement -> . assignment
    (44) statement -> . ifstatement
    (45) statement -> . whilestatement
    (46) declaration -> . type idlist SEMICOLON
    (30) voidfuncall -> . funcall SEMICOLON
    (51) assignment -> . pointer EQUALS expression SEMICOLON
    (52) assignment -> . var EQUALS expression SEMICOLON
    (66) ifstatement -> . IF LPAREN condition RPAREN controlbody
    (67) ifstatement -> . IF LPAREN condition RPAREN controlbody ELSE controlbody
    (68) whilestatement -> . WHILE LPAREN condition RPAREN controlbody
    (8) type -> . INT
    (9) type -> . VOID
    (10) type -> . FLOAT
    (31) funcall -> . var LPAREN params RPAREN
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (21) var -> . ID

    COMMENT         shift and go to state 50
    RBRACE          reduce using rule 42 (statements -> .)
    IF              shift and go to state 58
    WHILE           shift and go to state 48
    INT             shift and go to state 5
    VOID            shift and go to state 10
    FLOAT           shift and go to state 7
    TIMES           shift and go to state 16
    ID              shift and go to state 31

    statements                     shift and go to state 70
    statement                      shift and go to state 52
    assignment                     shift and go to state 56
    whilestatement                 shift and go to state 51
    funcall                        shift and go to state 47
    voidfuncall                    shift and go to state 55
    declaration                    shift and go to state 57
    var                            shift and go to state 53
    type                           shift and go to state 54
    pointer                        shift and go to state 49
    ifstatement                    shift and go to state 59

state 58

    (66) ifstatement -> IF . LPAREN condition RPAREN controlbody
    (67) ifstatement -> IF . LPAREN condition RPAREN controlbody ELSE controlbody

    LPAREN          shift and go to state 71


state 59

    (44) statement -> ifstatement .

    COMMENT         reduce using rule 44 (statement -> ifstatement .)
    IF              reduce using rule 44 (statement -> ifstatement .)
    WHILE           reduce using rule 44 (statement -> ifstatement .)
    INT             reduce using rule 44 (statement -> ifstatement .)
    VOID            reduce using rule 44 (statement -> ifstatement .)
    FLOAT           reduce using rule 44 (statement -> ifstatement .)
    TIMES           reduce using rule 44 (statement -> ifstatement .)
    ID              reduce using rule 44 (statement -> ifstatement .)
    RBRACE          reduce using rule 44 (statement -> ifstatement .)
    ELSE            reduce using rule 44 (statement -> ifstatement .)


state 60

    (15) argcomp -> COMMA arg argcomp .

    RPAREN          reduce using rule 15 (argcomp -> COMMA arg argcomp .)


state 61

    (6) function -> ftypename LPAREN args RPAREN LBRACE statements RBRACE .

    INT             reduce using rule 6 (function -> ftypename LPAREN args RPAREN LBRACE statements RBRACE .)
    VOID            reduce using rule 6 (function -> ftypename LPAREN args RPAREN LBRACE statements RBRACE .)
    FLOAT           reduce using rule 6 (function -> ftypename LPAREN args RPAREN LBRACE statements RBRACE .)
    $end            reduce using rule 6 (function -> ftypename LPAREN args RPAREN LBRACE statements RBRACE .)


state 62

    (30) voidfuncall -> funcall SEMICOLON .

    COMMENT         reduce using rule 30 (voidfuncall -> funcall SEMICOLON .)
    IF              reduce using rule 30 (voidfuncall -> funcall SEMICOLON .)
    WHILE           reduce using rule 30 (voidfuncall -> funcall SEMICOLON .)
    INT             reduce using rule 30 (voidfuncall -> funcall SEMICOLON .)
    VOID            reduce using rule 30 (voidfuncall -> funcall SEMICOLON .)
    FLOAT           reduce using rule 30 (voidfuncall -> funcall SEMICOLON .)
    TIMES           reduce using rule 30 (voidfuncall -> funcall SEMICOLON .)
    ID              reduce using rule 30 (voidfuncall -> funcall SEMICOLON .)
    RBRACE          reduce using rule 30 (voidfuncall -> funcall SEMICOLON .)


state 63

    (68) whilestatement -> WHILE LPAREN . condition RPAREN controlbody
    (53) condition -> . expression LT expression
    (54) condition -> . expression GT expression
    (55) condition -> . expression LE expression
    (56) condition -> . expression GE expression
    (57) condition -> . expression EQ expression
    (58) condition -> . expression NE expression
    (59) condition -> . condition AND condition
    (60) condition -> . condition OR condition
    (61) condition -> . NOT condition
    (62) condition -> . LPAREN condition RPAREN
    (69) expression -> . expression PLUS expression
    (70) expression -> . expression MINUS expression
    (71) expression -> . expression TIMES expression
    (72) expression -> . expression DIVIDE expression
    (73) expression -> . pointer
    (74) expression -> . address
    (75) expression -> . const
    (76) expression -> . var
    (77) expression -> . funcall
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . MINUS expression
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (31) funcall -> . var LPAREN params RPAREN

    NOT             shift and go to state 82
    LPAREN          shift and go to state 77
    MINUS           shift and go to state 75
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31

    const                          shift and go to state 79
    pointer                        shift and go to state 74
    funcall                        shift and go to state 73
    address                        shift and go to state 78
    var                            shift and go to state 76
    expression                     shift and go to state 83
    condition                      shift and go to state 80

state 64

    (51) assignment -> pointer EQUALS . expression SEMICOLON
    (69) expression -> . expression PLUS expression
    (70) expression -> . expression MINUS expression
    (71) expression -> . expression TIMES expression
    (72) expression -> . expression DIVIDE expression
    (73) expression -> . pointer
    (74) expression -> . address
    (75) expression -> . const
    (76) expression -> . var
    (77) expression -> . funcall
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . MINUS expression
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (31) funcall -> . var LPAREN params RPAREN

    LPAREN          shift and go to state 84
    MINUS           shift and go to state 75
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31

    const                          shift and go to state 79
    pointer                        shift and go to state 74
    funcall                        shift and go to state 73
    address                        shift and go to state 78
    var                            shift and go to state 76
    expression                     shift and go to state 85

state 65

    (39) statements -> COMMENT statements .

    RBRACE          reduce using rule 39 (statements -> COMMENT statements .)


state 66

    (38) statements -> statement statements .

    RBRACE          reduce using rule 38 (statements -> statement statements .)


state 67

    (52) assignment -> var EQUALS . expression SEMICOLON
    (69) expression -> . expression PLUS expression
    (70) expression -> . expression MINUS expression
    (71) expression -> . expression TIMES expression
    (72) expression -> . expression DIVIDE expression
    (73) expression -> . pointer
    (74) expression -> . address
    (75) expression -> . const
    (76) expression -> . var
    (77) expression -> . funcall
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . MINUS expression
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (31) funcall -> . var LPAREN params RPAREN

    LPAREN          shift and go to state 84
    MINUS           shift and go to state 75
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31

    const                          shift and go to state 79
    expression                     shift and go to state 86
    funcall                        shift and go to state 73
    address                        shift and go to state 78
    var                            shift and go to state 76
    pointer                        shift and go to state 74

state 68

    (31) funcall -> var LPAREN . params RPAREN
    (32) params -> . callparam paramcomp
    (33) params -> .
    (36) callparam -> . param
    (37) callparam -> . const
    (18) param -> . var
    (19) param -> . pointer
    (20) param -> . address
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var

    RPAREN          reduce using rule 33 (params -> .)
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27

    const                          shift and go to state 90
    param                          shift and go to state 87
    callparam                      shift and go to state 88
    params                         shift and go to state 89
    address                        shift and go to state 37
    var                            shift and go to state 38
    pointer                        shift and go to state 39

state 69

    (41) statements -> voidfuncall statements .

    RBRACE          reduce using rule 41 (statements -> voidfuncall statements .)


state 70

    (40) statements -> declaration statements .

    RBRACE          reduce using rule 40 (statements -> declaration statements .)


state 71

    (66) ifstatement -> IF LPAREN . condition RPAREN controlbody
    (67) ifstatement -> IF LPAREN . condition RPAREN controlbody ELSE controlbody
    (53) condition -> . expression LT expression
    (54) condition -> . expression GT expression
    (55) condition -> . expression LE expression
    (56) condition -> . expression GE expression
    (57) condition -> . expression EQ expression
    (58) condition -> . expression NE expression
    (59) condition -> . condition AND condition
    (60) condition -> . condition OR condition
    (61) condition -> . NOT condition
    (62) condition -> . LPAREN condition RPAREN
    (69) expression -> . expression PLUS expression
    (70) expression -> . expression MINUS expression
    (71) expression -> . expression TIMES expression
    (72) expression -> . expression DIVIDE expression
    (73) expression -> . pointer
    (74) expression -> . address
    (75) expression -> . const
    (76) expression -> . var
    (77) expression -> . funcall
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . MINUS expression
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (31) funcall -> . var LPAREN params RPAREN

    NOT             shift and go to state 82
    LPAREN          shift and go to state 77
    MINUS           shift and go to state 75
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31

    const                          shift and go to state 79
    pointer                        shift and go to state 74
    funcall                        shift and go to state 73
    address                        shift and go to state 78
    var                            shift and go to state 76
    expression                     shift and go to state 83
    condition                      shift and go to state 91

state 72

    (22) const -> NUMBER .

    PLUS            reduce using rule 22 (const -> NUMBER .)
    MINUS           reduce using rule 22 (const -> NUMBER .)
    TIMES           reduce using rule 22 (const -> NUMBER .)
    DIVIDE          reduce using rule 22 (const -> NUMBER .)
    LT              reduce using rule 22 (const -> NUMBER .)
    GT              reduce using rule 22 (const -> NUMBER .)
    LE              reduce using rule 22 (const -> NUMBER .)
    GE              reduce using rule 22 (const -> NUMBER .)
    EQ              reduce using rule 22 (const -> NUMBER .)
    NE              reduce using rule 22 (const -> NUMBER .)
    SEMICOLON       reduce using rule 22 (const -> NUMBER .)
    RPAREN          reduce using rule 22 (const -> NUMBER .)
    AND             reduce using rule 22 (const -> NUMBER .)
    OR              reduce using rule 22 (const -> NUMBER .)
    COMMA           reduce using rule 22 (const -> NUMBER .)


state 73

    (77) expression -> funcall .

    PLUS            reduce using rule 77 (expression -> funcall .)
    MINUS           reduce using rule 77 (expression -> funcall .)
    TIMES           reduce using rule 77 (expression -> funcall .)
    DIVIDE          reduce using rule 77 (expression -> funcall .)
    LT              reduce using rule 77 (expression -> funcall .)
    GT              reduce using rule 77 (expression -> funcall .)
    LE              reduce using rule 77 (expression -> funcall .)
    GE              reduce using rule 77 (expression -> funcall .)
    EQ              reduce using rule 77 (expression -> funcall .)
    NE              reduce using rule 77 (expression -> funcall .)
    SEMICOLON       reduce using rule 77 (expression -> funcall .)
    RPAREN          reduce using rule 77 (expression -> funcall .)
    AND             reduce using rule 77 (expression -> funcall .)
    OR              reduce using rule 77 (expression -> funcall .)


state 74

    (73) expression -> pointer .

    PLUS            reduce using rule 73 (expression -> pointer .)
    MINUS           reduce using rule 73 (expression -> pointer .)
    TIMES           reduce using rule 73 (expression -> pointer .)
    DIVIDE          reduce using rule 73 (expression -> pointer .)
    LT              reduce using rule 73 (expression -> pointer .)
    GT              reduce using rule 73 (expression -> pointer .)
    LE              reduce using rule 73 (expression -> pointer .)
    GE              reduce using rule 73 (expression -> pointer .)
    EQ              reduce using rule 73 (expression -> pointer .)
    NE              reduce using rule 73 (expression -> pointer .)
    SEMICOLON       reduce using rule 73 (expression -> pointer .)
    RPAREN          reduce using rule 73 (expression -> pointer .)
    AND             reduce using rule 73 (expression -> pointer .)
    OR              reduce using rule 73 (expression -> pointer .)


state 75

    (79) expression -> MINUS . expression
    (69) expression -> . expression PLUS expression
    (70) expression -> . expression MINUS expression
    (71) expression -> . expression TIMES expression
    (72) expression -> . expression DIVIDE expression
    (73) expression -> . pointer
    (74) expression -> . address
    (75) expression -> . const
    (76) expression -> . var
    (77) expression -> . funcall
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . MINUS expression
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (31) funcall -> . var LPAREN params RPAREN

    LPAREN          shift and go to state 84
    MINUS           shift and go to state 75
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31

    const                          shift and go to state 79
    expression                     shift and go to state 92
    funcall                        shift and go to state 73
    address                        shift and go to state 78
    var                            shift and go to state 76
    pointer                        shift and go to state 74

state 76

    (76) expression -> var .
    (31) funcall -> var . LPAREN params RPAREN

    PLUS            reduce using rule 76 (expression -> var .)
    MINUS           reduce using rule 76 (expression -> var .)
    TIMES           reduce using rule 76 (expression -> var .)
    DIVIDE          reduce using rule 76 (expression -> var .)
    LT              reduce using rule 76 (expression -> var .)
    GT              reduce using rule 76 (expression -> var .)
    LE              reduce using rule 76 (expression -> var .)
    GE              reduce using rule 76 (expression -> var .)
    EQ              reduce using rule 76 (expression -> var .)
    NE              reduce using rule 76 (expression -> var .)
    SEMICOLON       reduce using rule 76 (expression -> var .)
    RPAREN          reduce using rule 76 (expression -> var .)
    AND             reduce using rule 76 (expression -> var .)
    OR              reduce using rule 76 (expression -> var .)
    LPAREN          shift and go to state 68


state 77

    (62) condition -> LPAREN . condition RPAREN
    (78) expression -> LPAREN . expression RPAREN
    (53) condition -> . expression LT expression
    (54) condition -> . expression GT expression
    (55) condition -> . expression LE expression
    (56) condition -> . expression GE expression
    (57) condition -> . expression EQ expression
    (58) condition -> . expression NE expression
    (59) condition -> . condition AND condition
    (60) condition -> . condition OR condition
    (61) condition -> . NOT condition
    (62) condition -> . LPAREN condition RPAREN
    (69) expression -> . expression PLUS expression
    (70) expression -> . expression MINUS expression
    (71) expression -> . expression TIMES expression
    (72) expression -> . expression DIVIDE expression
    (73) expression -> . pointer
    (74) expression -> . address
    (75) expression -> . const
    (76) expression -> . var
    (77) expression -> . funcall
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . MINUS expression
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (31) funcall -> . var LPAREN params RPAREN

    NOT             shift and go to state 82
    LPAREN          shift and go to state 77
    MINUS           shift and go to state 75
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31

    const                          shift and go to state 79
    expression                     shift and go to state 94
    funcall                        shift and go to state 73
    address                        shift and go to state 78
    var                            shift and go to state 76
    pointer                        shift and go to state 74
    condition                      shift and go to state 93

state 78

    (74) expression -> address .

    PLUS            reduce using rule 74 (expression -> address .)
    MINUS           reduce using rule 74 (expression -> address .)
    TIMES           reduce using rule 74 (expression -> address .)
    DIVIDE          reduce using rule 74 (expression -> address .)
    LT              reduce using rule 74 (expression -> address .)
    GT              reduce using rule 74 (expression -> address .)
    LE              reduce using rule 74 (expression -> address .)
    GE              reduce using rule 74 (expression -> address .)
    EQ              reduce using rule 74 (expression -> address .)
    NE              reduce using rule 74 (expression -> address .)
    SEMICOLON       reduce using rule 74 (expression -> address .)
    RPAREN          reduce using rule 74 (expression -> address .)
    AND             reduce using rule 74 (expression -> address .)
    OR              reduce using rule 74 (expression -> address .)


state 79

    (75) expression -> const .

    PLUS            reduce using rule 75 (expression -> const .)
    MINUS           reduce using rule 75 (expression -> const .)
    TIMES           reduce using rule 75 (expression -> const .)
    DIVIDE          reduce using rule 75 (expression -> const .)
    LT              reduce using rule 75 (expression -> const .)
    GT              reduce using rule 75 (expression -> const .)
    LE              reduce using rule 75 (expression -> const .)
    GE              reduce using rule 75 (expression -> const .)
    EQ              reduce using rule 75 (expression -> const .)
    NE              reduce using rule 75 (expression -> const .)
    SEMICOLON       reduce using rule 75 (expression -> const .)
    RPAREN          reduce using rule 75 (expression -> const .)
    AND             reduce using rule 75 (expression -> const .)
    OR              reduce using rule 75 (expression -> const .)


state 80

    (68) whilestatement -> WHILE LPAREN condition . RPAREN controlbody
    (59) condition -> condition . AND condition
    (60) condition -> condition . OR condition

    RPAREN          shift and go to state 96
    AND             shift and go to state 95
    OR              shift and go to state 97


state 81

    (23) const -> FLOAT .

    PLUS            reduce using rule 23 (const -> FLOAT .)
    MINUS           reduce using rule 23 (const -> FLOAT .)
    TIMES           reduce using rule 23 (const -> FLOAT .)
    DIVIDE          reduce using rule 23 (const -> FLOAT .)
    LT              reduce using rule 23 (const -> FLOAT .)
    GT              reduce using rule 23 (const -> FLOAT .)
    LE              reduce using rule 23 (const -> FLOAT .)
    GE              reduce using rule 23 (const -> FLOAT .)
    EQ              reduce using rule 23 (const -> FLOAT .)
    NE              reduce using rule 23 (const -> FLOAT .)
    SEMICOLON       reduce using rule 23 (const -> FLOAT .)
    RPAREN          reduce using rule 23 (const -> FLOAT .)
    AND             reduce using rule 23 (const -> FLOAT .)
    OR              reduce using rule 23 (const -> FLOAT .)
    COMMA           reduce using rule 23 (const -> FLOAT .)


state 82

    (61) condition -> NOT . condition
    (53) condition -> . expression LT expression
    (54) condition -> . expression GT expression
    (55) condition -> . expression LE expression
    (56) condition -> . expression GE expression
    (57) condition -> . expression EQ expression
    (58) condition -> . expression NE expression
    (59) condition -> . condition AND condition
    (60) condition -> . condition OR condition
    (61) condition -> . NOT condition
    (62) condition -> . LPAREN condition RPAREN
    (69) expression -> . expression PLUS expression
    (70) expression -> . expression MINUS expression
    (71) expression -> . expression TIMES expression
    (72) expression -> . expression DIVIDE expression
    (73) expression -> . pointer
    (74) expression -> . address
    (75) expression -> . const
    (76) expression -> . var
    (77) expression -> . funcall
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . MINUS expression
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (31) funcall -> . var LPAREN params RPAREN

    NOT             shift and go to state 82
    LPAREN          shift and go to state 77
    MINUS           shift and go to state 75
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31

    const                          shift and go to state 79
    expression                     shift and go to state 83
    funcall                        shift and go to state 73
    address                        shift and go to state 78
    var                            shift and go to state 76
    pointer                        shift and go to state 74
    condition                      shift and go to state 98

state 83

    (53) condition -> expression . LT expression
    (54) condition -> expression . GT expression
    (55) condition -> expression . LE expression
    (56) condition -> expression . GE expression
    (57) condition -> expression . EQ expression
    (58) condition -> expression . NE expression
    (69) expression -> expression . PLUS expression
    (70) expression -> expression . MINUS expression
    (71) expression -> expression . TIMES expression
    (72) expression -> expression . DIVIDE expression

    LT              shift and go to state 102
    GT              shift and go to state 99
    LE              shift and go to state 105
    GE              shift and go to state 104
    EQ              shift and go to state 101
    NE              shift and go to state 103
    PLUS            shift and go to state 106
    MINUS           shift and go to state 108
    TIMES           shift and go to state 107
    DIVIDE          shift and go to state 100


state 84

    (78) expression -> LPAREN . expression RPAREN
    (69) expression -> . expression PLUS expression
    (70) expression -> . expression MINUS expression
    (71) expression -> . expression TIMES expression
    (72) expression -> . expression DIVIDE expression
    (73) expression -> . pointer
    (74) expression -> . address
    (75) expression -> . const
    (76) expression -> . var
    (77) expression -> . funcall
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . MINUS expression
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (31) funcall -> . var LPAREN params RPAREN

    LPAREN          shift and go to state 84
    MINUS           shift and go to state 75
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31

    const                          shift and go to state 79
    expression                     shift and go to state 109
    funcall                        shift and go to state 73
    address                        shift and go to state 78
    var                            shift and go to state 76
    pointer                        shift and go to state 74

state 85

    (51) assignment -> pointer EQUALS expression . SEMICOLON
    (69) expression -> expression . PLUS expression
    (70) expression -> expression . MINUS expression
    (71) expression -> expression . TIMES expression
    (72) expression -> expression . DIVIDE expression

    SEMICOLON       shift and go to state 110
    PLUS            shift and go to state 106
    MINUS           shift and go to state 108
    TIMES           shift and go to state 107
    DIVIDE          shift and go to state 100


state 86

    (52) assignment -> var EQUALS expression . SEMICOLON
    (69) expression -> expression . PLUS expression
    (70) expression -> expression . MINUS expression
    (71) expression -> expression . TIMES expression
    (72) expression -> expression . DIVIDE expression

    SEMICOLON       shift and go to state 111
    PLUS            shift and go to state 106
    MINUS           shift and go to state 108
    TIMES           shift and go to state 107
    DIVIDE          shift and go to state 100


state 87

    (36) callparam -> param .

    COMMA           reduce using rule 36 (callparam -> param .)
    RPAREN          reduce using rule 36 (callparam -> param .)


state 88

    (32) params -> callparam . paramcomp
    (34) paramcomp -> . COMMA callparam paramcomp
    (35) paramcomp -> .

    COMMA           shift and go to state 113
    RPAREN          reduce using rule 35 (paramcomp -> .)

    paramcomp                      shift and go to state 112

state 89

    (31) funcall -> var LPAREN params . RPAREN

    RPAREN          shift and go to state 114


state 90

    (37) callparam -> const .

    COMMA           reduce using rule 37 (callparam -> const .)
    RPAREN          reduce using rule 37 (callparam -> const .)


state 91

    (66) ifstatement -> IF LPAREN condition . RPAREN controlbody
    (67) ifstatement -> IF LPAREN condition . RPAREN controlbody ELSE controlbody
    (59) condition -> condition . AND condition
    (60) condition -> condition . OR condition

    RPAREN          shift and go to state 115
    AND             shift and go to state 95
    OR              shift and go to state 97


state 92

    (79) expression -> MINUS expression .
    (69) expression -> expression . PLUS expression
    (70) expression -> expression . MINUS expression
    (71) expression -> expression . TIMES expression
    (72) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 79 (expression -> MINUS expression .)
    MINUS           reduce using rule 79 (expression -> MINUS expression .)
    TIMES           reduce using rule 79 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 79 (expression -> MINUS expression .)
    LT              reduce using rule 79 (expression -> MINUS expression .)
    GT              reduce using rule 79 (expression -> MINUS expression .)
    LE              reduce using rule 79 (expression -> MINUS expression .)
    GE              reduce using rule 79 (expression -> MINUS expression .)
    EQ              reduce using rule 79 (expression -> MINUS expression .)
    NE              reduce using rule 79 (expression -> MINUS expression .)
    SEMICOLON       reduce using rule 79 (expression -> MINUS expression .)
    RPAREN          reduce using rule 79 (expression -> MINUS expression .)
    AND             reduce using rule 79 (expression -> MINUS expression .)
    OR              reduce using rule 79 (expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 106 ]
  ! MINUS           [ shift and go to state 108 ]
  ! TIMES           [ shift and go to state 107 ]
  ! DIVIDE          [ shift and go to state 100 ]


state 93

    (62) condition -> LPAREN condition . RPAREN
    (59) condition -> condition . AND condition
    (60) condition -> condition . OR condition

    RPAREN          shift and go to state 116
    AND             shift and go to state 95
    OR              shift and go to state 97


state 94

    (78) expression -> LPAREN expression . RPAREN
    (53) condition -> expression . LT expression
    (54) condition -> expression . GT expression
    (55) condition -> expression . LE expression
    (56) condition -> expression . GE expression
    (57) condition -> expression . EQ expression
    (58) condition -> expression . NE expression
    (69) expression -> expression . PLUS expression
    (70) expression -> expression . MINUS expression
    (71) expression -> expression . TIMES expression
    (72) expression -> expression . DIVIDE expression

    RPAREN          shift and go to state 117
    LT              shift and go to state 102
    GT              shift and go to state 99
    LE              shift and go to state 105
    GE              shift and go to state 104
    EQ              shift and go to state 101
    NE              shift and go to state 103
    PLUS            shift and go to state 106
    MINUS           shift and go to state 108
    TIMES           shift and go to state 107
    DIVIDE          shift and go to state 100


state 95

    (59) condition -> condition AND . condition
    (53) condition -> . expression LT expression
    (54) condition -> . expression GT expression
    (55) condition -> . expression LE expression
    (56) condition -> . expression GE expression
    (57) condition -> . expression EQ expression
    (58) condition -> . expression NE expression
    (59) condition -> . condition AND condition
    (60) condition -> . condition OR condition
    (61) condition -> . NOT condition
    (62) condition -> . LPAREN condition RPAREN
    (69) expression -> . expression PLUS expression
    (70) expression -> . expression MINUS expression
    (71) expression -> . expression TIMES expression
    (72) expression -> . expression DIVIDE expression
    (73) expression -> . pointer
    (74) expression -> . address
    (75) expression -> . const
    (76) expression -> . var
    (77) expression -> . funcall
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . MINUS expression
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (31) funcall -> . var LPAREN params RPAREN

    NOT             shift and go to state 82
    LPAREN          shift and go to state 77
    MINUS           shift and go to state 75
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31

    const                          shift and go to state 79
    expression                     shift and go to state 83
    funcall                        shift and go to state 73
    address                        shift and go to state 78
    var                            shift and go to state 76
    pointer                        shift and go to state 74
    condition                      shift and go to state 118

state 96

    (68) whilestatement -> WHILE LPAREN condition RPAREN . controlbody
    (63) controlbody -> . LBRACE statements RBRACE
    (64) controlbody -> . statement
    (65) controlbody -> . SEMICOLON
    (43) statement -> . assignment
    (44) statement -> . ifstatement
    (45) statement -> . whilestatement
    (51) assignment -> . pointer EQUALS expression SEMICOLON
    (52) assignment -> . var EQUALS expression SEMICOLON
    (66) ifstatement -> . IF LPAREN condition RPAREN controlbody
    (67) ifstatement -> . IF LPAREN condition RPAREN controlbody ELSE controlbody
    (68) whilestatement -> . WHILE LPAREN condition RPAREN controlbody
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (21) var -> . ID

    LBRACE          shift and go to state 123
    SEMICOLON       shift and go to state 119
    IF              shift and go to state 58
    WHILE           shift and go to state 48
    TIMES           shift and go to state 16
    ID              shift and go to state 31

    assignment                     shift and go to state 56
    whilestatement                 shift and go to state 51
    pointer                        shift and go to state 49
    statement                      shift and go to state 121
    var                            shift and go to state 122
    controlbody                    shift and go to state 120
    ifstatement                    shift and go to state 59

state 97

    (60) condition -> condition OR . condition
    (53) condition -> . expression LT expression
    (54) condition -> . expression GT expression
    (55) condition -> . expression LE expression
    (56) condition -> . expression GE expression
    (57) condition -> . expression EQ expression
    (58) condition -> . expression NE expression
    (59) condition -> . condition AND condition
    (60) condition -> . condition OR condition
    (61) condition -> . NOT condition
    (62) condition -> . LPAREN condition RPAREN
    (69) expression -> . expression PLUS expression
    (70) expression -> . expression MINUS expression
    (71) expression -> . expression TIMES expression
    (72) expression -> . expression DIVIDE expression
    (73) expression -> . pointer
    (74) expression -> . address
    (75) expression -> . const
    (76) expression -> . var
    (77) expression -> . funcall
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . MINUS expression
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (31) funcall -> . var LPAREN params RPAREN

    NOT             shift and go to state 82
    LPAREN          shift and go to state 77
    MINUS           shift and go to state 75
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31

    const                          shift and go to state 79
    expression                     shift and go to state 83
    funcall                        shift and go to state 73
    address                        shift and go to state 78
    var                            shift and go to state 76
    pointer                        shift and go to state 74
    condition                      shift and go to state 124

state 98

    (61) condition -> NOT condition .
    (59) condition -> condition . AND condition
    (60) condition -> condition . OR condition

    RPAREN          reduce using rule 61 (condition -> NOT condition .)
    AND             reduce using rule 61 (condition -> NOT condition .)
    OR              reduce using rule 61 (condition -> NOT condition .)

  ! AND             [ shift and go to state 95 ]
  ! OR              [ shift and go to state 97 ]


state 99

    (54) condition -> expression GT . expression
    (69) expression -> . expression PLUS expression
    (70) expression -> . expression MINUS expression
    (71) expression -> . expression TIMES expression
    (72) expression -> . expression DIVIDE expression
    (73) expression -> . pointer
    (74) expression -> . address
    (75) expression -> . const
    (76) expression -> . var
    (77) expression -> . funcall
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . MINUS expression
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (31) funcall -> . var LPAREN params RPAREN

    LPAREN          shift and go to state 84
    MINUS           shift and go to state 75
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31

    const                          shift and go to state 79
    expression                     shift and go to state 125
    funcall                        shift and go to state 73
    address                        shift and go to state 78
    var                            shift and go to state 76
    pointer                        shift and go to state 74

state 100

    (72) expression -> expression DIVIDE . expression
    (69) expression -> . expression PLUS expression
    (70) expression -> . expression MINUS expression
    (71) expression -> . expression TIMES expression
    (72) expression -> . expression DIVIDE expression
    (73) expression -> . pointer
    (74) expression -> . address
    (75) expression -> . const
    (76) expression -> . var
    (77) expression -> . funcall
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . MINUS expression
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (31) funcall -> . var LPAREN params RPAREN

    LPAREN          shift and go to state 84
    MINUS           shift and go to state 75
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31

    const                          shift and go to state 79
    expression                     shift and go to state 126
    funcall                        shift and go to state 73
    address                        shift and go to state 78
    var                            shift and go to state 76
    pointer                        shift and go to state 74

state 101

    (57) condition -> expression EQ . expression
    (69) expression -> . expression PLUS expression
    (70) expression -> . expression MINUS expression
    (71) expression -> . expression TIMES expression
    (72) expression -> . expression DIVIDE expression
    (73) expression -> . pointer
    (74) expression -> . address
    (75) expression -> . const
    (76) expression -> . var
    (77) expression -> . funcall
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . MINUS expression
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (31) funcall -> . var LPAREN params RPAREN

    LPAREN          shift and go to state 84
    MINUS           shift and go to state 75
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31

    const                          shift and go to state 79
    expression                     shift and go to state 127
    funcall                        shift and go to state 73
    address                        shift and go to state 78
    var                            shift and go to state 76
    pointer                        shift and go to state 74

state 102

    (53) condition -> expression LT . expression
    (69) expression -> . expression PLUS expression
    (70) expression -> . expression MINUS expression
    (71) expression -> . expression TIMES expression
    (72) expression -> . expression DIVIDE expression
    (73) expression -> . pointer
    (74) expression -> . address
    (75) expression -> . const
    (76) expression -> . var
    (77) expression -> . funcall
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . MINUS expression
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (31) funcall -> . var LPAREN params RPAREN

    LPAREN          shift and go to state 84
    MINUS           shift and go to state 75
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31

    const                          shift and go to state 79
    expression                     shift and go to state 128
    funcall                        shift and go to state 73
    address                        shift and go to state 78
    var                            shift and go to state 76
    pointer                        shift and go to state 74

state 103

    (58) condition -> expression NE . expression
    (69) expression -> . expression PLUS expression
    (70) expression -> . expression MINUS expression
    (71) expression -> . expression TIMES expression
    (72) expression -> . expression DIVIDE expression
    (73) expression -> . pointer
    (74) expression -> . address
    (75) expression -> . const
    (76) expression -> . var
    (77) expression -> . funcall
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . MINUS expression
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (31) funcall -> . var LPAREN params RPAREN

    LPAREN          shift and go to state 84
    MINUS           shift and go to state 75
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31

    const                          shift and go to state 79
    expression                     shift and go to state 129
    funcall                        shift and go to state 73
    address                        shift and go to state 78
    var                            shift and go to state 76
    pointer                        shift and go to state 74

state 104

    (56) condition -> expression GE . expression
    (69) expression -> . expression PLUS expression
    (70) expression -> . expression MINUS expression
    (71) expression -> . expression TIMES expression
    (72) expression -> . expression DIVIDE expression
    (73) expression -> . pointer
    (74) expression -> . address
    (75) expression -> . const
    (76) expression -> . var
    (77) expression -> . funcall
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . MINUS expression
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (31) funcall -> . var LPAREN params RPAREN

    LPAREN          shift and go to state 84
    MINUS           shift and go to state 75
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31

    const                          shift and go to state 79
    expression                     shift and go to state 130
    funcall                        shift and go to state 73
    address                        shift and go to state 78
    var                            shift and go to state 76
    pointer                        shift and go to state 74

state 105

    (55) condition -> expression LE . expression
    (69) expression -> . expression PLUS expression
    (70) expression -> . expression MINUS expression
    (71) expression -> . expression TIMES expression
    (72) expression -> . expression DIVIDE expression
    (73) expression -> . pointer
    (74) expression -> . address
    (75) expression -> . const
    (76) expression -> . var
    (77) expression -> . funcall
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . MINUS expression
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (31) funcall -> . var LPAREN params RPAREN

    LPAREN          shift and go to state 84
    MINUS           shift and go to state 75
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31

    const                          shift and go to state 79
    expression                     shift and go to state 131
    funcall                        shift and go to state 73
    address                        shift and go to state 78
    var                            shift and go to state 76
    pointer                        shift and go to state 74

state 106

    (69) expression -> expression PLUS . expression
    (69) expression -> . expression PLUS expression
    (70) expression -> . expression MINUS expression
    (71) expression -> . expression TIMES expression
    (72) expression -> . expression DIVIDE expression
    (73) expression -> . pointer
    (74) expression -> . address
    (75) expression -> . const
    (76) expression -> . var
    (77) expression -> . funcall
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . MINUS expression
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (31) funcall -> . var LPAREN params RPAREN

    LPAREN          shift and go to state 84
    MINUS           shift and go to state 75
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31

    const                          shift and go to state 79
    expression                     shift and go to state 132
    funcall                        shift and go to state 73
    address                        shift and go to state 78
    var                            shift and go to state 76
    pointer                        shift and go to state 74

state 107

    (71) expression -> expression TIMES . expression
    (69) expression -> . expression PLUS expression
    (70) expression -> . expression MINUS expression
    (71) expression -> . expression TIMES expression
    (72) expression -> . expression DIVIDE expression
    (73) expression -> . pointer
    (74) expression -> . address
    (75) expression -> . const
    (76) expression -> . var
    (77) expression -> . funcall
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . MINUS expression
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (31) funcall -> . var LPAREN params RPAREN

    LPAREN          shift and go to state 84
    MINUS           shift and go to state 75
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31

    const                          shift and go to state 79
    expression                     shift and go to state 133
    funcall                        shift and go to state 73
    address                        shift and go to state 78
    var                            shift and go to state 76
    pointer                        shift and go to state 74

state 108

    (70) expression -> expression MINUS . expression
    (69) expression -> . expression PLUS expression
    (70) expression -> . expression MINUS expression
    (71) expression -> . expression TIMES expression
    (72) expression -> . expression DIVIDE expression
    (73) expression -> . pointer
    (74) expression -> . address
    (75) expression -> . const
    (76) expression -> . var
    (77) expression -> . funcall
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . MINUS expression
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (31) funcall -> . var LPAREN params RPAREN

    LPAREN          shift and go to state 84
    MINUS           shift and go to state 75
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27
    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31

    const                          shift and go to state 79
    expression                     shift and go to state 134
    funcall                        shift and go to state 73
    address                        shift and go to state 78
    var                            shift and go to state 76
    pointer                        shift and go to state 74

state 109

    (78) expression -> LPAREN expression . RPAREN
    (69) expression -> expression . PLUS expression
    (70) expression -> expression . MINUS expression
    (71) expression -> expression . TIMES expression
    (72) expression -> expression . DIVIDE expression

    RPAREN          shift and go to state 117
    PLUS            shift and go to state 106
    MINUS           shift and go to state 108
    TIMES           shift and go to state 107
    DIVIDE          shift and go to state 100


state 110

    (51) assignment -> pointer EQUALS expression SEMICOLON .

    COMMENT         reduce using rule 51 (assignment -> pointer EQUALS expression SEMICOLON .)
    IF              reduce using rule 51 (assignment -> pointer EQUALS expression SEMICOLON .)
    WHILE           reduce using rule 51 (assignment -> pointer EQUALS expression SEMICOLON .)
    INT             reduce using rule 51 (assignment -> pointer EQUALS expression SEMICOLON .)
    VOID            reduce using rule 51 (assignment -> pointer EQUALS expression SEMICOLON .)
    FLOAT           reduce using rule 51 (assignment -> pointer EQUALS expression SEMICOLON .)
    TIMES           reduce using rule 51 (assignment -> pointer EQUALS expression SEMICOLON .)
    ID              reduce using rule 51 (assignment -> pointer EQUALS expression SEMICOLON .)
    RBRACE          reduce using rule 51 (assignment -> pointer EQUALS expression SEMICOLON .)
    ELSE            reduce using rule 51 (assignment -> pointer EQUALS expression SEMICOLON .)


state 111

    (52) assignment -> var EQUALS expression SEMICOLON .

    COMMENT         reduce using rule 52 (assignment -> var EQUALS expression SEMICOLON .)
    IF              reduce using rule 52 (assignment -> var EQUALS expression SEMICOLON .)
    WHILE           reduce using rule 52 (assignment -> var EQUALS expression SEMICOLON .)
    INT             reduce using rule 52 (assignment -> var EQUALS expression SEMICOLON .)
    VOID            reduce using rule 52 (assignment -> var EQUALS expression SEMICOLON .)
    FLOAT           reduce using rule 52 (assignment -> var EQUALS expression SEMICOLON .)
    TIMES           reduce using rule 52 (assignment -> var EQUALS expression SEMICOLON .)
    ID              reduce using rule 52 (assignment -> var EQUALS expression SEMICOLON .)
    RBRACE          reduce using rule 52 (assignment -> var EQUALS expression SEMICOLON .)
    ELSE            reduce using rule 52 (assignment -> var EQUALS expression SEMICOLON .)


state 112

    (32) params -> callparam paramcomp .

    RPAREN          reduce using rule 32 (params -> callparam paramcomp .)


state 113

    (34) paramcomp -> COMMA . callparam paramcomp
    (36) callparam -> . param
    (37) callparam -> . const
    (18) param -> . var
    (19) param -> . pointer
    (20) param -> . address
    (22) const -> . NUMBER
    (23) const -> . FLOAT
    (21) var -> . ID
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (27) address -> . AMPERSAND pointer
    (28) address -> . AMPERSAND address
    (29) address -> . AMPERSAND var

    NUMBER          shift and go to state 72
    FLOAT           shift and go to state 81
    ID              shift and go to state 31
    TIMES           shift and go to state 16
    AMPERSAND       shift and go to state 27

    const                          shift and go to state 90
    param                          shift and go to state 87
    callparam                      shift and go to state 135
    address                        shift and go to state 37
    var                            shift and go to state 38
    pointer                        shift and go to state 39

state 114

    (31) funcall -> var LPAREN params RPAREN .

    PLUS            reduce using rule 31 (funcall -> var LPAREN params RPAREN .)
    MINUS           reduce using rule 31 (funcall -> var LPAREN params RPAREN .)
    TIMES           reduce using rule 31 (funcall -> var LPAREN params RPAREN .)
    DIVIDE          reduce using rule 31 (funcall -> var LPAREN params RPAREN .)
    RPAREN          reduce using rule 31 (funcall -> var LPAREN params RPAREN .)
    AND             reduce using rule 31 (funcall -> var LPAREN params RPAREN .)
    OR              reduce using rule 31 (funcall -> var LPAREN params RPAREN .)
    LT              reduce using rule 31 (funcall -> var LPAREN params RPAREN .)
    GT              reduce using rule 31 (funcall -> var LPAREN params RPAREN .)
    LE              reduce using rule 31 (funcall -> var LPAREN params RPAREN .)
    GE              reduce using rule 31 (funcall -> var LPAREN params RPAREN .)
    EQ              reduce using rule 31 (funcall -> var LPAREN params RPAREN .)
    NE              reduce using rule 31 (funcall -> var LPAREN params RPAREN .)
    SEMICOLON       reduce using rule 31 (funcall -> var LPAREN params RPAREN .)


state 115

    (66) ifstatement -> IF LPAREN condition RPAREN . controlbody
    (67) ifstatement -> IF LPAREN condition RPAREN . controlbody ELSE controlbody
    (63) controlbody -> . LBRACE statements RBRACE
    (64) controlbody -> . statement
    (65) controlbody -> . SEMICOLON
    (43) statement -> . assignment
    (44) statement -> . ifstatement
    (45) statement -> . whilestatement
    (51) assignment -> . pointer EQUALS expression SEMICOLON
    (52) assignment -> . var EQUALS expression SEMICOLON
    (66) ifstatement -> . IF LPAREN condition RPAREN controlbody
    (67) ifstatement -> . IF LPAREN condition RPAREN controlbody ELSE controlbody
    (68) whilestatement -> . WHILE LPAREN condition RPAREN controlbody
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (21) var -> . ID

    LBRACE          shift and go to state 123
    SEMICOLON       shift and go to state 119
    IF              shift and go to state 58
    WHILE           shift and go to state 48
    TIMES           shift and go to state 16
    ID              shift and go to state 31

    assignment                     shift and go to state 56
    whilestatement                 shift and go to state 51
    pointer                        shift and go to state 49
    statement                      shift and go to state 121
    var                            shift and go to state 122
    controlbody                    shift and go to state 136
    ifstatement                    shift and go to state 59

state 116

    (62) condition -> LPAREN condition RPAREN .

    RPAREN          reduce using rule 62 (condition -> LPAREN condition RPAREN .)
    AND             reduce using rule 62 (condition -> LPAREN condition RPAREN .)
    OR              reduce using rule 62 (condition -> LPAREN condition RPAREN .)


state 117

    (78) expression -> LPAREN expression RPAREN .

    PLUS            reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    NE              reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 78 (expression -> LPAREN expression RPAREN .)


state 118

    (59) condition -> condition AND condition .
    (59) condition -> condition . AND condition
    (60) condition -> condition . OR condition

    RPAREN          reduce using rule 59 (condition -> condition AND condition .)
    AND             reduce using rule 59 (condition -> condition AND condition .)
    OR              reduce using rule 59 (condition -> condition AND condition .)

  ! AND             [ shift and go to state 95 ]
  ! OR              [ shift and go to state 97 ]


state 119

    (65) controlbody -> SEMICOLON .

    COMMENT         reduce using rule 65 (controlbody -> SEMICOLON .)
    IF              reduce using rule 65 (controlbody -> SEMICOLON .)
    WHILE           reduce using rule 65 (controlbody -> SEMICOLON .)
    INT             reduce using rule 65 (controlbody -> SEMICOLON .)
    VOID            reduce using rule 65 (controlbody -> SEMICOLON .)
    FLOAT           reduce using rule 65 (controlbody -> SEMICOLON .)
    TIMES           reduce using rule 65 (controlbody -> SEMICOLON .)
    ID              reduce using rule 65 (controlbody -> SEMICOLON .)
    RBRACE          reduce using rule 65 (controlbody -> SEMICOLON .)
    ELSE            reduce using rule 65 (controlbody -> SEMICOLON .)


state 120

    (68) whilestatement -> WHILE LPAREN condition RPAREN controlbody .

    COMMENT         reduce using rule 68 (whilestatement -> WHILE LPAREN condition RPAREN controlbody .)
    IF              reduce using rule 68 (whilestatement -> WHILE LPAREN condition RPAREN controlbody .)
    WHILE           reduce using rule 68 (whilestatement -> WHILE LPAREN condition RPAREN controlbody .)
    INT             reduce using rule 68 (whilestatement -> WHILE LPAREN condition RPAREN controlbody .)
    VOID            reduce using rule 68 (whilestatement -> WHILE LPAREN condition RPAREN controlbody .)
    FLOAT           reduce using rule 68 (whilestatement -> WHILE LPAREN condition RPAREN controlbody .)
    TIMES           reduce using rule 68 (whilestatement -> WHILE LPAREN condition RPAREN controlbody .)
    ID              reduce using rule 68 (whilestatement -> WHILE LPAREN condition RPAREN controlbody .)
    RBRACE          reduce using rule 68 (whilestatement -> WHILE LPAREN condition RPAREN controlbody .)
    ELSE            reduce using rule 68 (whilestatement -> WHILE LPAREN condition RPAREN controlbody .)


state 121

    (64) controlbody -> statement .

    COMMENT         reduce using rule 64 (controlbody -> statement .)
    IF              reduce using rule 64 (controlbody -> statement .)
    WHILE           reduce using rule 64 (controlbody -> statement .)
    INT             reduce using rule 64 (controlbody -> statement .)
    VOID            reduce using rule 64 (controlbody -> statement .)
    FLOAT           reduce using rule 64 (controlbody -> statement .)
    TIMES           reduce using rule 64 (controlbody -> statement .)
    ID              reduce using rule 64 (controlbody -> statement .)
    RBRACE          reduce using rule 64 (controlbody -> statement .)
    ELSE            reduce using rule 64 (controlbody -> statement .)


state 122

    (52) assignment -> var . EQUALS expression SEMICOLON

    EQUALS          shift and go to state 67


state 123

    (63) controlbody -> LBRACE . statements RBRACE
    (38) statements -> . statement statements
    (39) statements -> . COMMENT statements
    (40) statements -> . declaration statements
    (41) statements -> . voidfuncall statements
    (42) statements -> .
    (43) statement -> . assignment
    (44) statement -> . ifstatement
    (45) statement -> . whilestatement
    (46) declaration -> . type idlist SEMICOLON
    (30) voidfuncall -> . funcall SEMICOLON
    (51) assignment -> . pointer EQUALS expression SEMICOLON
    (52) assignment -> . var EQUALS expression SEMICOLON
    (66) ifstatement -> . IF LPAREN condition RPAREN controlbody
    (67) ifstatement -> . IF LPAREN condition RPAREN controlbody ELSE controlbody
    (68) whilestatement -> . WHILE LPAREN condition RPAREN controlbody
    (8) type -> . INT
    (9) type -> . VOID
    (10) type -> . FLOAT
    (31) funcall -> . var LPAREN params RPAREN
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (21) var -> . ID

    COMMENT         shift and go to state 50
    RBRACE          reduce using rule 42 (statements -> .)
    IF              shift and go to state 58
    WHILE           shift and go to state 48
    INT             shift and go to state 5
    VOID            shift and go to state 10
    FLOAT           shift and go to state 7
    TIMES           shift and go to state 16
    ID              shift and go to state 31

    statements                     shift and go to state 137
    statement                      shift and go to state 52
    assignment                     shift and go to state 56
    whilestatement                 shift and go to state 51
    funcall                        shift and go to state 47
    voidfuncall                    shift and go to state 55
    declaration                    shift and go to state 57
    var                            shift and go to state 53
    type                           shift and go to state 54
    pointer                        shift and go to state 49
    ifstatement                    shift and go to state 59

state 124

    (60) condition -> condition OR condition .
    (59) condition -> condition . AND condition
    (60) condition -> condition . OR condition

    RPAREN          reduce using rule 60 (condition -> condition OR condition .)
    OR              reduce using rule 60 (condition -> condition OR condition .)
    AND             shift and go to state 95

  ! AND             [ reduce using rule 60 (condition -> condition OR condition .) ]
  ! OR              [ shift and go to state 97 ]


state 125

    (54) condition -> expression GT expression .
    (69) expression -> expression . PLUS expression
    (70) expression -> expression . MINUS expression
    (71) expression -> expression . TIMES expression
    (72) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 54 (condition -> expression GT expression .)
    AND             reduce using rule 54 (condition -> expression GT expression .)
    OR              reduce using rule 54 (condition -> expression GT expression .)
    PLUS            shift and go to state 106
    MINUS           shift and go to state 108
    TIMES           shift and go to state 107
    DIVIDE          shift and go to state 100


state 126

    (72) expression -> expression DIVIDE expression .
    (69) expression -> expression . PLUS expression
    (70) expression -> expression . MINUS expression
    (71) expression -> expression . TIMES expression
    (72) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 72 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 72 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 72 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 72 (expression -> expression DIVIDE expression .)
    LT              reduce using rule 72 (expression -> expression DIVIDE expression .)
    GT              reduce using rule 72 (expression -> expression DIVIDE expression .)
    LE              reduce using rule 72 (expression -> expression DIVIDE expression .)
    GE              reduce using rule 72 (expression -> expression DIVIDE expression .)
    EQ              reduce using rule 72 (expression -> expression DIVIDE expression .)
    NE              reduce using rule 72 (expression -> expression DIVIDE expression .)
    SEMICOLON       reduce using rule 72 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 72 (expression -> expression DIVIDE expression .)
    AND             reduce using rule 72 (expression -> expression DIVIDE expression .)
    OR              reduce using rule 72 (expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 106 ]
  ! MINUS           [ shift and go to state 108 ]
  ! TIMES           [ shift and go to state 107 ]
  ! DIVIDE          [ shift and go to state 100 ]


state 127

    (57) condition -> expression EQ expression .
    (69) expression -> expression . PLUS expression
    (70) expression -> expression . MINUS expression
    (71) expression -> expression . TIMES expression
    (72) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 57 (condition -> expression EQ expression .)
    AND             reduce using rule 57 (condition -> expression EQ expression .)
    OR              reduce using rule 57 (condition -> expression EQ expression .)
    PLUS            shift and go to state 106
    MINUS           shift and go to state 108
    TIMES           shift and go to state 107
    DIVIDE          shift and go to state 100


state 128

    (53) condition -> expression LT expression .
    (69) expression -> expression . PLUS expression
    (70) expression -> expression . MINUS expression
    (71) expression -> expression . TIMES expression
    (72) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 53 (condition -> expression LT expression .)
    AND             reduce using rule 53 (condition -> expression LT expression .)
    OR              reduce using rule 53 (condition -> expression LT expression .)
    PLUS            shift and go to state 106
    MINUS           shift and go to state 108
    TIMES           shift and go to state 107
    DIVIDE          shift and go to state 100


state 129

    (58) condition -> expression NE expression .
    (69) expression -> expression . PLUS expression
    (70) expression -> expression . MINUS expression
    (71) expression -> expression . TIMES expression
    (72) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 58 (condition -> expression NE expression .)
    AND             reduce using rule 58 (condition -> expression NE expression .)
    OR              reduce using rule 58 (condition -> expression NE expression .)
    PLUS            shift and go to state 106
    MINUS           shift and go to state 108
    TIMES           shift and go to state 107
    DIVIDE          shift and go to state 100


state 130

    (56) condition -> expression GE expression .
    (69) expression -> expression . PLUS expression
    (70) expression -> expression . MINUS expression
    (71) expression -> expression . TIMES expression
    (72) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 56 (condition -> expression GE expression .)
    AND             reduce using rule 56 (condition -> expression GE expression .)
    OR              reduce using rule 56 (condition -> expression GE expression .)
    PLUS            shift and go to state 106
    MINUS           shift and go to state 108
    TIMES           shift and go to state 107
    DIVIDE          shift and go to state 100


state 131

    (55) condition -> expression LE expression .
    (69) expression -> expression . PLUS expression
    (70) expression -> expression . MINUS expression
    (71) expression -> expression . TIMES expression
    (72) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 55 (condition -> expression LE expression .)
    AND             reduce using rule 55 (condition -> expression LE expression .)
    OR              reduce using rule 55 (condition -> expression LE expression .)
    PLUS            shift and go to state 106
    MINUS           shift and go to state 108
    TIMES           shift and go to state 107
    DIVIDE          shift and go to state 100


state 132

    (69) expression -> expression PLUS expression .
    (69) expression -> expression . PLUS expression
    (70) expression -> expression . MINUS expression
    (71) expression -> expression . TIMES expression
    (72) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 69 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 69 (expression -> expression PLUS expression .)
    LT              reduce using rule 69 (expression -> expression PLUS expression .)
    GT              reduce using rule 69 (expression -> expression PLUS expression .)
    LE              reduce using rule 69 (expression -> expression PLUS expression .)
    GE              reduce using rule 69 (expression -> expression PLUS expression .)
    EQ              reduce using rule 69 (expression -> expression PLUS expression .)
    NE              reduce using rule 69 (expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 69 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 69 (expression -> expression PLUS expression .)
    AND             reduce using rule 69 (expression -> expression PLUS expression .)
    OR              reduce using rule 69 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 107
    DIVIDE          shift and go to state 100

  ! TIMES           [ reduce using rule 69 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 69 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 106 ]
  ! MINUS           [ shift and go to state 108 ]


state 133

    (71) expression -> expression TIMES expression .
    (69) expression -> expression . PLUS expression
    (70) expression -> expression . MINUS expression
    (71) expression -> expression . TIMES expression
    (72) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 71 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 71 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 71 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 71 (expression -> expression TIMES expression .)
    LT              reduce using rule 71 (expression -> expression TIMES expression .)
    GT              reduce using rule 71 (expression -> expression TIMES expression .)
    LE              reduce using rule 71 (expression -> expression TIMES expression .)
    GE              reduce using rule 71 (expression -> expression TIMES expression .)
    EQ              reduce using rule 71 (expression -> expression TIMES expression .)
    NE              reduce using rule 71 (expression -> expression TIMES expression .)
    SEMICOLON       reduce using rule 71 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 71 (expression -> expression TIMES expression .)
    AND             reduce using rule 71 (expression -> expression TIMES expression .)
    OR              reduce using rule 71 (expression -> expression TIMES expression .)

  ! PLUS            [ shift and go to state 106 ]
  ! MINUS           [ shift and go to state 108 ]
  ! TIMES           [ shift and go to state 107 ]
  ! DIVIDE          [ shift and go to state 100 ]


state 134

    (70) expression -> expression MINUS expression .
    (69) expression -> expression . PLUS expression
    (70) expression -> expression . MINUS expression
    (71) expression -> expression . TIMES expression
    (72) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 70 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 70 (expression -> expression MINUS expression .)
    LT              reduce using rule 70 (expression -> expression MINUS expression .)
    GT              reduce using rule 70 (expression -> expression MINUS expression .)
    LE              reduce using rule 70 (expression -> expression MINUS expression .)
    GE              reduce using rule 70 (expression -> expression MINUS expression .)
    EQ              reduce using rule 70 (expression -> expression MINUS expression .)
    NE              reduce using rule 70 (expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 70 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 70 (expression -> expression MINUS expression .)
    AND             reduce using rule 70 (expression -> expression MINUS expression .)
    OR              reduce using rule 70 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 107
    DIVIDE          shift and go to state 100

  ! TIMES           [ reduce using rule 70 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 70 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 106 ]
  ! MINUS           [ shift and go to state 108 ]


state 135

    (34) paramcomp -> COMMA callparam . paramcomp
    (34) paramcomp -> . COMMA callparam paramcomp
    (35) paramcomp -> .

    COMMA           shift and go to state 113
    RPAREN          reduce using rule 35 (paramcomp -> .)

    paramcomp                      shift and go to state 138

state 136

    (66) ifstatement -> IF LPAREN condition RPAREN controlbody .
    (67) ifstatement -> IF LPAREN condition RPAREN controlbody . ELSE controlbody

    COMMENT         reduce using rule 66 (ifstatement -> IF LPAREN condition RPAREN controlbody .)
    IF              reduce using rule 66 (ifstatement -> IF LPAREN condition RPAREN controlbody .)
    WHILE           reduce using rule 66 (ifstatement -> IF LPAREN condition RPAREN controlbody .)
    INT             reduce using rule 66 (ifstatement -> IF LPAREN condition RPAREN controlbody .)
    VOID            reduce using rule 66 (ifstatement -> IF LPAREN condition RPAREN controlbody .)
    FLOAT           reduce using rule 66 (ifstatement -> IF LPAREN condition RPAREN controlbody .)
    TIMES           reduce using rule 66 (ifstatement -> IF LPAREN condition RPAREN controlbody .)
    ID              reduce using rule 66 (ifstatement -> IF LPAREN condition RPAREN controlbody .)
    RBRACE          reduce using rule 66 (ifstatement -> IF LPAREN condition RPAREN controlbody .)
    ELSE            shift and go to state 139

  ! ELSE            [ reduce using rule 66 (ifstatement -> IF LPAREN condition RPAREN controlbody .) ]


state 137

    (63) controlbody -> LBRACE statements . RBRACE

    RBRACE          shift and go to state 140


state 138

    (34) paramcomp -> COMMA callparam paramcomp .

    RPAREN          reduce using rule 34 (paramcomp -> COMMA callparam paramcomp .)


state 139

    (67) ifstatement -> IF LPAREN condition RPAREN controlbody ELSE . controlbody
    (63) controlbody -> . LBRACE statements RBRACE
    (64) controlbody -> . statement
    (65) controlbody -> . SEMICOLON
    (43) statement -> . assignment
    (44) statement -> . ifstatement
    (45) statement -> . whilestatement
    (51) assignment -> . pointer EQUALS expression SEMICOLON
    (52) assignment -> . var EQUALS expression SEMICOLON
    (66) ifstatement -> . IF LPAREN condition RPAREN controlbody
    (67) ifstatement -> . IF LPAREN condition RPAREN controlbody ELSE controlbody
    (68) whilestatement -> . WHILE LPAREN condition RPAREN controlbody
    (24) pointer -> . TIMES pointer
    (25) pointer -> . TIMES address
    (26) pointer -> . TIMES var
    (21) var -> . ID

    LBRACE          shift and go to state 123
    SEMICOLON       shift and go to state 119
    IF              shift and go to state 58
    WHILE           shift and go to state 48
    TIMES           shift and go to state 16
    ID              shift and go to state 31

    assignment                     shift and go to state 56
    whilestatement                 shift and go to state 51
    pointer                        shift and go to state 49
    statement                      shift and go to state 121
    var                            shift and go to state 122
    controlbody                    shift and go to state 141
    ifstatement                    shift and go to state 59

state 140

    (63) controlbody -> LBRACE statements RBRACE .

    COMMENT         reduce using rule 63 (controlbody -> LBRACE statements RBRACE .)
    IF              reduce using rule 63 (controlbody -> LBRACE statements RBRACE .)
    WHILE           reduce using rule 63 (controlbody -> LBRACE statements RBRACE .)
    INT             reduce using rule 63 (controlbody -> LBRACE statements RBRACE .)
    VOID            reduce using rule 63 (controlbody -> LBRACE statements RBRACE .)
    FLOAT           reduce using rule 63 (controlbody -> LBRACE statements RBRACE .)
    TIMES           reduce using rule 63 (controlbody -> LBRACE statements RBRACE .)
    ID              reduce using rule 63 (controlbody -> LBRACE statements RBRACE .)
    RBRACE          reduce using rule 63 (controlbody -> LBRACE statements RBRACE .)
    ELSE            reduce using rule 63 (controlbody -> LBRACE statements RBRACE .)


state 141

    (67) ifstatement -> IF LPAREN condition RPAREN controlbody ELSE controlbody .

    COMMENT         reduce using rule 67 (ifstatement -> IF LPAREN condition RPAREN controlbody ELSE controlbody .)
    IF              reduce using rule 67 (ifstatement -> IF LPAREN condition RPAREN controlbody ELSE controlbody .)
    WHILE           reduce using rule 67 (ifstatement -> IF LPAREN condition RPAREN controlbody ELSE controlbody .)
    INT             reduce using rule 67 (ifstatement -> IF LPAREN condition RPAREN controlbody ELSE controlbody .)
    VOID            reduce using rule 67 (ifstatement -> IF LPAREN condition RPAREN controlbody ELSE controlbody .)
    FLOAT           reduce using rule 67 (ifstatement -> IF LPAREN condition RPAREN controlbody ELSE controlbody .)
    TIMES           reduce using rule 67 (ifstatement -> IF LPAREN condition RPAREN controlbody ELSE controlbody .)
    ID              reduce using rule 67 (ifstatement -> IF LPAREN condition RPAREN controlbody ELSE controlbody .)
    RBRACE          reduce using rule 67 (ifstatement -> IF LPAREN condition RPAREN controlbody ELSE controlbody .)
    ELSE            reduce using rule 67 (ifstatement -> IF LPAREN condition RPAREN controlbody ELSE controlbody .)

